<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>LEGO Version 1.3: Theorems and Configure Theorems</title>
  </head>

  <body>  <P>
 <HR> 
<A HREF="utac.html">
<IMG ALIGN=MIDDLE
SRC="http://www.dcs.ed.ac.uk/icons//next_motif.gif"></A> 

<A HREF="newfeatures.html"> 
<IMG ALIGN=MIDDLE SRC="http://www.dcs.ed.ac.uk/icons//up_motif.gif"></A>

<A HREF="then.html">
<IMG ALIGN=MIDDLE
SRC="http://www.dcs.ed.ac.uk/icons//previous_motif.gif"></A>

<A HREF="../index.html"><IMG ALIGN=MIDDLE SRC="http://www.dcs.ed.ac.uk/icons//contents_motif.gif"></A>
 <BR>

<B> Next:</B> <A  HREF="utac.html">UTac</A>
<B> Up:</B> <A  HREF="newfeatures.html">LEGO Release 1.3 Documentation </A>
<B> Previous:</B> <A HREF="then.html">Then </A>
<HR>
      <h1>LEGO Version 1.3: Theorems and Configure Theorems</h1>

Simple inductive datatypes can be equipped with useful gadgets by the
new version of the <b>Theorems</b> switch, in accordance with the
parameters set up by the <b>Configure Theorems</b> command. This
configuration can work in one of two ways:

<ul>
<li> <tt>Configure Theorems</tt> <i>true_type</i> <i>absurd_type</i>
                                 <i>eq_subst</i><tt>;</tt> <p>
     instructs Theorems to prepare proof that constructors are disjoint
     via the substitutive property of equality, where <i>eq_subst</i>
     is the name of this property as registered with
      <A HREF="config_eq.html"><b>Configure Equality</b></a>,
     and <i>true_type</i> and <i>absurd_type</i> are the names of
     (respectively) the polymorphic identity function and absurd
     function types for an appropriate universe (eg <tt>trueProp</tt>
     and <tt>absurd</tt> for <tt>Prop</tt>).<p>
<li> <tt>Configure Theorems</tt> <i>true_value</i> <i>false_value</i>
                                 <i>true_not_false</i><tt>;</tt> <p>
     instructs Theorems to prepare similar proofs by mapping conflicting
     constructors to the named distinct <i>true_value</i>
     and <i>false_value</i> and applying the named <i>true_not_false</i>
     proof that they are distinct.<p>
</ul>
<P><PRE>
  Inductive [simple:SET] Theorems
  Constructors
    [con1:T11->..->T1j1->simple]
    ..
    [conk:Tk1->..->Tkjk->simple];
</PRE><P>
will build for each constructor <TT>coni</TT> a function
<tt>simple_is_coni</tt>
<P>
acting like
<P>
<tt>&#160;&#160;fun simple_is_coni (coni xi1 .. xiji) =</tt>
      <i>true_type</i> or <i>true_value</i><br>
<tt>&#160;&#160;&#160;&#160;| simple_is_coni                  _ =</tt>
      <i>absurd_type</i> or <i>false_value</i>
<P>
These functions can then be used, with <i>eq_subst</i> or <i>true_not_false</i>
according to the configuration, to synthesise constructor conflict theorems
as required.
<P>
Also constructed where possible are the injectivity theorems:
<P>
<tt>&#160;&#160;simple_coni_injective : {xi1,yi1|Ti1}..{xiji,yiji|Tiji}</tt>
<br>
<tt>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
&#160;&#160;&#160;&#160;
(Eq (coni xi1 .. xiji) (coni yi1 .. yiji))-></tt><br>
<tt>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
&#160;&#160;&#160;&#160;&#160;{P|</tt><i>subst_univ</i><tt>}
((Eq xi1 yi1)->..->(Eq xiji yiji)->P)->P</tt><p>
where <i>subst_univ</i> is the universe over which <i>eq_subst</i>
substitutes.
<P>
At present, LEGO fails to generate an injectivity theorem for any
constructor whose arguments contain type dependencies such that the
injected equalities are not well-typed. In these circumstances, the
user is informed of the omission, but the inductive definition goes
though anyway, along with those injectivity theorems which can be
generated.
<P>
Note that the Theorems package uses the equality set up by
<A HREF="config_eq.html"><b>Configure Equality</b></a>.
The library's default equality comes with an appropriate
Theorems configuration.
<P>
The <A HREF="qnify.html"><b>Qnify</b></a> tactic uses the facilities
generated by Theorems to solve first-order unification problems
involving constructors and variables expressed as equational premises
in the goal.
<P>
</body>
</html>