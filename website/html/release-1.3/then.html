<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>LEGO Version 1.3: Then</title>
  </head>

  <body>  <P>
 <HR> 
<A HREF="theorems.html">
<IMG ALIGN=MIDDLE
SRC="http://www.dcs.ed.ac.uk/icons//next_motif.gif"></A> 

<A HREF="newfeatures.html"> 
<IMG ALIGN=MIDDLE SRC="http://www.dcs.ed.ac.uk/icons//up_motif.gif"></A>

<A HREF="objectcomp/objectcomp.html">
<IMG ALIGN=MIDDLE
SRC="http://www.dcs.ed.ac.uk/icons//previous_motif.gif"></A>

<A HREF="../index.html"><IMG ALIGN=MIDDLE SRC="http://www.dcs.ed.ac.uk/icons//contents_motif.gif"></A>
 <BR>

<B> Next:</B> <A  HREF="theorems.html">Theorems and Configure Theorems</A>
<B> Up:</B> <A  HREF="newfeatures.html">New features in LEGO Version 1.3</A>
<B> Previous:</B> <A HREF="objectcomp/objectcomp.html">Speedups</A>
<HR>
      <h1>LEGO Version 1.3: Then</h1>

Previously, the effect of
<P>
<ul><i>A</i> <tt>Then</tt> <i>B</i></tt></ul>
<P>
was to execute command <i>A</i>, then execute command <i>B</i>. ie
<i>B</i> was executed on whatever was the current subgoal after
<i>A</i> finished. If <i>A</i> left several subgoals, then <i>B</i>
was only executed on the first. If <i>A</i> discharged its goal, then
<i>B</i> was executed on whatever proof obligation surfaced next.
<P>
For this alpha release, the <tt>Then</tt> tactical has been modified
to reflect more accurately the LCF spirit.
<P>
Morally, the effect of <i>A</i> <tt>Then</tt> <i><i>B</i></tt>
should be to execute <i>A</i>, then execute <i>B</i> for each of the subgoals
generated by <i>A</i>, if there are any.
<P>
Unfortunately, if <i>A</i> leaves us with more than one subgoal,
running <i>B</i> on the first may leave the others
inaccessible. However, the new implementation tags these inaccessible
subgoals with an instruction to execute <i>B</i> automatically as soon
as each one resurfaces. Hence <i>B</i> is executed on each subgoal
generated by <i>A</i>.
<P>
It may be the case that <i>B</i> does not complete the proof of
<i>A</i>'s first subgoal, and that you may need to intervene. Once you
have finished off the branch and the next <i>A</i>-subgoal comes up,
<i>B</i> will happen to it before your eyes. This may prove slightly
disconcerting.
<P>
Here's an example:
<P><PRE>
  Lego> Goal plus: nat->nat->nat;
  Goal plus
     ?0 : nat->nat->nat
  Lego> Induction 1 Then intros;
  Refine by  nat_elim ([_:nat]nat->nat)
     ?1 : nat->nat
     ?2 : nat->(nat->nat)->nat->nat
  executing delayed Then tactic...               (* intros for ?1 *)
  intros (1) 
    H : nat
     ?3 : nat
  Lego> Refine H;                   (* user finishes off ?1 proof *)
  Refine by  H
  Discharge..  H
     ?2 : nat->(nat->nat)->nat->nat
  executing delayed Then tactic...               (* intros for ?2 *)
  intros (3) 
    x1 : nat
    x1_ih : nat->nat
    H : nat
     ?4 : nat
  Lego> Refine (suc (x1_ih H));
  Refine by  suc (x1_ih H)
  Discharge..  H x1_ih x1
  *** QED ***
</PRE><P>

<TT>Then</TT> behaves correctly with respect to <TT>Undo</tt>.
<tt>Undo</tt> <i>n</i> undoes <i>n</i> user commands. A tactical
compound counts as a single command. If you undo a command which was
followed by the automatic execution of a delayed <tt>Then</tt> tactic,
you will still return to the state before your command, incidentally
undoing the delayed tactic and replacing the tag on its goal.
<P>

One slight quirk is what happens to
<i>A</i> Then <i>B</i> if <i>A</i> succeeds but <i>B</i> fails.
Morally, if any instance of <i>B</i> fails, the whole <i>A</i> <tt>Then</tt>
<i>B</i> should fail. However, the latency in executing some
<i>B</i>'s makes this impractical. Hence our <i>A</i> <tt>Then</tt>
<i>B</i> really behaves like <i>A</i> <tt>Then</tt>
(<tt>Try</tt> <i>B</i>).
<p>
An ideal implementation of <tt>Then</tt> requires the ability to
switch between different branches of the proof in their different
contexts. This is difficult because implicit synthesis of existential
variables can cause interference between branches. What has been done
falls well short of this ideal, but it nonetheless a powerful and
effort-saving tool.


</body>
</html>